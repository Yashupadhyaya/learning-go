// ********RoostGPT********
/*
Test generated by RoostGPT for test go-single-file-test using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=jumpSearch_cf44201f2c
ROOST_METHOD_SIG_HASH=jumpSearch_45970a9b95

Scenario 1: Query integer is present in the array

Details:
  Description: This test is meant to check if the function correctly returns the index of the searched integer if it is present in the array.
Execution:
  Arrange: An array of integers in ascending order and a query integer that is present in the array.
  Act: Invoke the jumpSearch function with the array and the query integer as parameters.
  Assert: Use the Go testing facility to check if the returned index matches the expected index.
Validation:
  The choice of assertion is to verify the correctness of the search algorithm. The test is important to ensure that the function works as expected when the searched integer is present in the array.

Scenario 2: Query integer is not present in the array

Details:
  Description: This test is meant to check if the function correctly returns -1 when the searched integer is not present in the array.
Execution:
  Arrange: An array of integers in ascending order and a query integer that is not present in the array.
  Act: Invoke the jumpSearch function with the array and the query integer as parameters.
  Assert: Use the Go testing facility to check if the returned value is -1.
Validation:
  The choice of assertion is to verify that the function correctly handles the case when the searched integer is not found. The test is important to ensure that the function does not return incorrect results or crash when the query integer is absent.

Scenario 3: Empty array

Details:
  Description: This test is meant to check if the function correctly returns -1 when the array is empty.
Execution:
  Arrange: An empty array and a query integer.
  Act: Invoke the jumpSearch function with the empty array and the query integer as parameters.
  Assert: Use the Go testing facility to check if the returned value is -1.
Validation:
  The choice of assertion is to verify that the function correctly handles the edge case of an empty array. The test is important to ensure that the function does not crash when provided with an empty array.

Scenario 4: Array with duplicate integers

Details:
  Description: This test is meant to check if the function correctly returns the index of the first occurrence of the searched integer when the array contains duplicate integers.
Execution:
  Arrange: An array of integers in ascending order with duplicates and a query integer that is present in the array.
  Act: Invoke the jumpSearch function with the array and the query integer as parameters.
  Assert: Use the Go testing facility to check if the returned index matches the index of the first occurrence of the query integer.
Validation:
  The choice of assertion is to verify that the function correctly handles arrays with duplicate integers. The test is important to ensure that the function works as expected in real-world scenarios where the array may contain duplicates.
*/

// ********RoostGPT********
package JumpSearch

import (
	"math"
	"testing"
)

func Testjumpsearch(t *testing.T) {
	tests := []struct {
		name     string
		arr      []int
		query    int
		expected int
	}{
		{
			name:     "Query integer is present in the array",
			arr:      []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
			query:    7,
			expected: 6,
		},
		{
			name:     "Query integer is not present in the array",
			arr:      []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10},
			query:    11,
			expected: -1,
		},
		{
			name:     "Empty array",
			arr:      []int{},
			query:    1,
			expected: -1,
		},
		{
			name:     "Array with duplicate integers",
			arr:      []int{1, 2, 3, 3, 4, 4, 5, 5, 6, 6},
			query:    4,
			expected: 4,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := jumpSearch(tt.arr, tt.query); got != tt.expected {
				t.Errorf("jumpSearch() = %v, want %v", got, tt.expected)
			}
		})
	}
}

func jumpSearch(arr []int, query int) int {
	size := len(arr)
	step := int(math.Sqrt(float64(size)))
	prev := 0
	if size == 0 {
		return -1
	}
	for arr[int(math.Min(float64(step), float64(size)))-1] < query {
		prev = step
		step += int(math.Sqrt(float64(size)))
		if prev >= size {
			return -1
		}
	}
	for arr[prev] < query {
		prev++
		if prev == int(math.Min(float64(step), float64(size))) {
			return -1
		}
	}
	if arr[prev] == query {
		return prev
	}
	return -1
}

// ********RoostGPT********
/*
Test generated by RoostGPT for test go-unit-testing1 using AI Type  and AI Model 

ROOST_METHOD_HASH=isPrime_117a72a056
ROOST_METHOD_SIG_HASH=isPrime_54426e0153

Scenario 1: Testing with a Prime Number

Details:
  Description: This test is meant to check if the function isPrime correctly identifies a prime number. A prime number is a number greater than 1 that has no positive divisors other than 1 and itself.
Execution:
  Arrange: No setup is required for this test.
  Act: Invoke the isPrime function with a known prime number, such as 7.
  Assert: Use Go's testing facilities to verify that the function returns true.
Validation:
  The assertion checks that the function correctly identifies the number as prime. This test is important for verifying the core functionality of the function.

Scenario 2: Testing with a Non-Prime Number

Details:
  Description: This test is meant to check if the function isPrime correctly identifies a non-prime number.
Execution:
  Arrange: No setup is required for this test.
  Act: Invoke the isPrime function with a known non-prime number, such as 4.
  Assert: Use Go's testing facilities to verify that the function returns false.
Validation:
  The assertion checks that the function correctly identifies the number as non-prime. This test is important for verifying the core functionality of the function.

Scenario 3: Testing with a Negative Number

Details:
  Description: This test is meant to check how the function isPrime handles negative numbers. Since prime numbers are defined as being greater than 1, negative numbers should not be considered prime.
Execution:
  Arrange: No setup is required for this test.
  Act: Invoke the isPrime function with a negative number, such as -7.
  Assert: Use Go's testing facilities to verify that the function returns false.
Validation:
  The assertion checks that the function correctly identifies negative numbers as non-prime. This test is important for ensuring that the function handles edge cases correctly.

Scenario 4: Testing with Zero

Details:
  Description: This test is meant to check how the function isPrime handles zero. Since prime numbers are defined as being greater than 1, zero should not be considered prime.
Execution:
  Arrange: No setup is required for this test.
  Act: Invoke the isPrime function with 0.
  Assert: Use Go's testing facilities to verify that the function returns false.
Validation:
  The assertion checks that the function correctly identifies zero as non-prime. This test is important for ensuring that the function handles edge cases correctly.

Scenario 5: Testing with One

Details:
  Description: This test is meant to check how the function isPrime handles one. Since prime numbers are defined as being greater than 1, one should not be considered prime.
Execution:
  Arrange: No setup is required for this test.
  Act: Invoke the isPrime function with 1.
  Assert: Use Go's testing facilities to verify that the function returns false.
Validation:
  The assertion checks that the function correctly identifies one as non-prime. This test is important for ensuring that the function handles edge cases correctly.
*/

// ********RoostGPT********
package PrimalityTest

import (
	"testing"
)

func TestIsPrime(t *testing.T) {
	// define table driven tests
	tests := []struct {
		name string
		num  int
		want bool
	}{
		{"Prime Number", 7, true},
		{"Non-Prime Number", 4, false},
		{"Negative Number", -7, false},
		{"Zero", 0, false},
		{"One", 1, false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			if got := isPrime(tt.num); got != tt.want {
				t.Errorf("isPrime() = %v, want %v", got, tt.want)
			} else {
				t.Logf("Success: %v identified correctly", tt.name)
			}
		})
	}
}
